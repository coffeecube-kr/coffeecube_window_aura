const { app, BrowserWindow, session } = require("electron");
const path = require("path");
const { spawn } = require("child_process");

const isDev = process.env.NODE_ENV === "development";
let mainWindow;
let nextServer;
let pythonServer;

function createWindow() {
  // 이미 창이 존재하면 생성하지 않음
  if (mainWindow && !mainWindow.isDestroyed()) {
    console.log("Window already exists, focusing...");
    mainWindow.focus();
    return;
  }
  const { screen } = require("electron");
  const primaryDisplay = screen.getPrimaryDisplay();
  // 전체 화면 크기 사용 (태스크바 포함)
  const { width: screenWidth, height: screenHeight } = primaryDisplay.bounds;

  // 1080x1920 비율 유지하면서 높이를 화면에 맞춤
  const targetRatio = 1080 / 1920; // 0.5625 (9:16)
  const windowHeight = screenHeight;
  const windowWidth = Math.round(windowHeight * targetRatio);

  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    x: Math.round((screenWidth - windowWidth) / 2), // 가로 중앙 정렬
    y: 0,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: false, // 브라우저와 동일한 컨텍스트
      sandbox: true, // 브라우저와 동일한 보안 모델
      zoomFactor: 1.0,
      // Web Serial API 활성화
      enableBlinkFeatures: "Serial",
    },
    icon: path.join(__dirname, "../public/favicon.ico"),
    // 키오스크 모드 설정
    fullscreen: false,
    kiosk: false,
    frame: false, // 프레임 완전 제거하여 높이 확보
    autoHideMenuBar: true,
    resizable: true, // 전체 화면 모드를 위해 true로 변경
    maximizable: true, // 전체 화면 모드를 위해 true로 변경
    alwaysOnTop: !isDev, // 프로덕션에서는 항상 위에
    fullscreenable: true, // 전체 화면 가능하도록 설정
  });

  // User Agent는 Electron 기본값 사용 (데스크톱 Chrome)

  // 개발자 도구 열기 (프로덕션에서도 F12로 열 수 있도록)
  if (isDev) {
    mainWindow.webContents.openDevTools();
  }

  console.log(
    `Screen: ${screenWidth}x${screenHeight}, Window: ${windowWidth}x${windowHeight}`
  );

  // 항상 로컬 서버 사용
  const startUrl = "http://localhost:3000";

  console.log("Loading URL:", startUrl);

  // 서버가 준비될 때까지 대기 후 로드
  const loadUrlWithRetry = async (retries = 30) => {
    for (let i = 0; i < retries; i++) {
      try {
        await mainWindow.loadURL(startUrl);
        console.log("Successfully loaded URL");
        return;
      } catch (err) {
        console.log(`Waiting for server... (${i + 1}/${retries})`);
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }
    console.error("Failed to load URL after retries");
  };

  loadUrlWithRetry();

  // 로딩 실패 시 에러 로그
  mainWindow.webContents.on(
    "did-fail-load",
    (event, errorCode, errorDescription) => {
      console.error("Failed to load:", errorCode, errorDescription);
    }
  );

  // 페이지 로드 완료 시 스케일링 적용
  mainWindow.webContents.on("did-finish-load", () => {
    console.log("Page loaded successfully");
    applyScaling();
  });

  // 스케일링 적용 함수
  function applyScaling() {
    const bounds = mainWindow.getBounds();
    const currentWidth = bounds.width;
    const currentHeight = bounds.height;

    // 1080x1920 콘텐츠를 현재 창 크기에 맞게 스케일
    const scaleX = currentWidth / 1080;
    const scaleY = currentHeight / 1920;
    const scale = Math.min(scaleX, scaleY);

    mainWindow.webContents.setZoomFactor(scale);
    console.log(
      `Applied zoom factor: ${scale} (width: ${currentWidth}, height: ${currentHeight})`
    );
  }

  // F11 키로 전체 화면 토글
  let isInFullScreenMode = false;
  mainWindow.webContents.on("before-input-event", (event, input) => {
    if (input.key === "F11" && input.type === "keyDown") {
      isInFullScreenMode = !isInFullScreenMode;

      if (isInFullScreenMode) {
        // 전체 화면 모드: 모니터 전체를 채움
        mainWindow.setFullScreen(true);
        mainWindow.setKiosk(false); // kiosk는 false로 유지 (ESC로 나갈 수 있게)
        console.log("Entering fullscreen mode");
      } else {
        // 일반 모드: 원래 창 크기로 복귀
        mainWindow.setFullScreen(false);
        mainWindow.setKiosk(false);
        mainWindow.setBounds({
          width: windowWidth,
          height: windowHeight,
          x: Math.round((screenWidth - windowWidth) / 2),
          y: 0,
        });
        console.log("Exiting fullscreen mode");
      }

      // 전체 화면 전환 후 스케일링 재적용
      setTimeout(() => {
        applyScaling();
      }, 100);
    }
  });

  // 창 크기 변경 시 스케일링 재적용
  mainWindow.on("resize", () => {
    applyScaling();
  });

  mainWindow.on("closed", () => {
    mainWindow = null;
  });
}

// Next.js 서버 시작 함수
function startNextServer() {
  return new Promise((resolve) => {
    if (isDev) {
      // 개발 모드에서는 이미 실행 중인 서버 사용
      resolve();
      return;
    }

    // 프로덕션 모드에서 Next.js 서버 시작
    const isPackaged = app.isPackaged;
    const appPath = isPackaged
      ? path.join(process.resourcesPath, "app")
      : app.getAppPath();

    console.log("Starting Next.js server...");
    console.log("App path:", appPath);
    console.log("Is packaged:", isPackaged);
    console.log("process.resourcesPath:", process.resourcesPath);
    console.log("app.getAppPath():", app.getAppPath());

    // Next.js standalone 서버 실행
    const serverPath = path.join(appPath, ".next", "standalone", "server.js");
    const standalonePath = path.join(appPath, ".next", "standalone");

    console.log("Server path:", serverPath);
    console.log("Standalone path:", standalonePath);

    // 파일 존재 확인
    const fs = require("fs");
    if (!fs.existsSync(serverPath)) {
      console.error("ERROR: server.js not found at:", serverPath);
      console.error("Please run: npm run electron:package");

      // 에러 다이얼로그 표시
      const { dialog } = require("electron");
      dialog.showErrorBox(
        "Application Error",
        `Next.js server files not found.\n\nPath: ${serverPath}\n\nPlease reinstall the application.`
      );
      app.quit();
      return;
    }
    console.log("✓ server.js found");

    // Electron 내장 Node.js 사용 (다른 PC에 Node.js 설치 불필요)
    const nodePath = process.execPath.replace(/electron\.exe$/i, "node.exe");
    const useEmbeddedNode = fs.existsSync(nodePath);
    const nodeExecutable = useEmbeddedNode ? nodePath : process.execPath;

    console.log("Node executable:", nodeExecutable);

    // .env.local 파일 로드
    const envPath = path.join(appPath, ".env.local");
    let envVars = { ...process.env };

    if (fs.existsSync(envPath)) {
      console.log("✓ Loading .env.local from:", envPath);
      const envContent = fs.readFileSync(envPath, "utf8");
      envContent.split("\n").forEach((line) => {
        const match = line.match(/^([^=:#]+)=(.*)$/);
        if (match) {
          const key = match[1].trim();
          const value = match[2].trim();
          envVars[key] = value;
        }
      });
    } else {
      console.warn("⚠ .env.local not found at:", envPath);
    }

    nextServer = spawn(nodeExecutable, [serverPath], {
      cwd: standalonePath,
      env: {
        ...envVars,
        NODE_ENV: "production",
        PORT: "3000",
        HOSTNAME: "localhost",
      },
      stdio: ["ignore", "pipe", "pipe"],
    });

    // 서버 출력 로그
    nextServer.stdout.on("data", (data) => {
      console.log("[Next.js]:", data.toString());
    });

    nextServer.stderr.on("data", (data) => {
      console.error("[Next.js Error]:", data.toString());
    });

    nextServer.on("error", (err) => {
      console.error("Failed to start Next.js server:", err);
      const { dialog } = require("electron");
      dialog.showErrorBox(
        "Server Error",
        `Failed to start Next.js server: ${err.message}`
      );
    });

    nextServer.on("exit", (code) => {
      if (code !== 0) {
        console.error(`Next.js server exited with code ${code}`);
      }
    });

    // 서버가 실제로 준비될 때까지 대기
    const checkServer = async () => {
      const http = require("http");
      for (let i = 0; i < 30; i++) {
        try {
          await new Promise((resolveCheck, rejectCheck) => {
            const req = http.get("http://localhost:3000", (res) => {
              resolveCheck();
            });
            req.on("error", rejectCheck);
            req.setTimeout(1000, () => {
              req.destroy();
              rejectCheck(new Error("Timeout"));
            });
          });
          console.log("✓ Next.js server is ready!");
          resolve();
          return;
        } catch (err) {
          console.log(`Waiting for Next.js server... (${i + 1}/30)`);
          await new Promise((r) => setTimeout(r, 1000));
        }
      }
      console.error("✗ Next.js server failed to start");
      resolve(); // 타임아웃되어도 계속 진행
    };

    checkServer();
  });
}

// Single instance lock - 하나의 인스턴스만 실행되도록
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  console.log("Another instance is already running. Quitting...");
  app.quit();
} else {
  app.on("second-instance", () => {
    // 두 번째 인스턴스가 실행되려고 하면 기존 창을 포커스
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();

app.whenReady().then(async () => {
  // Serial API 권한 설정
  session.defaultSession.setPermissionCheckHandler(
    (webContents, permission) => {
      console.log(`Permission check: ${permission}`);
      if (permission === 'serial') {
        return true;
      }
      return false;
    }
  );

  session.defaultSession.setDevicePermissionHandler((details) => {
    console.log(`Device permission: ${details.deviceType}`);
    if (details.deviceType === 'serial') {
      return true;
    }
    return false;
    createWindow();
  });
}

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on("window-all-closed", () => {
  // Next.js 서버 종료
  if (nextServer) {
    nextServer.kill();
  }

  if (process.platform !== "darwin") {
    app.quit();
  }
});

// 앱 종료 시 Next.js 서버도 종료
app.on("before-quit", () => {
  if (nextServer) {
    nextServer.kill();
  }
});
